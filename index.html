<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Live DVR – Desktop & Mobile</title>
  <style>
    /* ---------- GENERAL ---------- */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: Arial, sans-serif;
      background: #222;
      color: #fff;
      overflow: hidden;
      position: fixed;
      width: 100%;
      /* Prevent text selection globally except inputs/textareas */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    /* Allow text selection in inputs/textareas */
    input, textarea {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    .container {
      display: flex;
      height: 100vh;
      width: 100%;
    }

    /* ---------- SIDEBAR ---------- */
    #sidebar {
      background: #444;
      width: 220px;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      transition: transform .3s ease;
      flex-shrink: 0;
      z-index: 1000;
      -webkit-overflow-scrolling: touch;
      /* Allow selection in sidebar */
      user-select: auto;
      -webkit-user-select: auto;
      -moz-user-select: auto;
      -ms-user-select: auto;
    }
    #sidebar.hidden {
       transform: translateX(-100%);
    }
    #btn-add-urls,
    .sideBtn,
    #urlModal button {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 8px;
      border: 1px solid #666;
      background-color: #555;
      color: #fff;
    }
    #btn-add-urls:hover,
    .sideBtn:hover,
    #urlModal button:hover {
      background-color: #666;
    }
    #sideButtons {
      display: flex;
      gap: 10px;
    }
    .sideBtn {
      flex: 1;
    }
    #streamList {
      margin-top: 10px;
      line-height: 1.2;
    }
    .no-streams {
      font-style: italic;
      color: #bbb;
    }
    .stream-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      padding: 5px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .stream-item.selecting {
      background-color: #666;
    }
    .stream-item:hover {
      background-color: #555;
    }
    .stream-item label {
      margin-left: 8px;
      cursor: pointer;
      user-select: none; /* Keep labels non-selectable */
      -webkit-user-select: none;
      flex-grow: 1;
    }
    .stream-item input[type="checkbox"] {
      cursor: pointer;
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    /* ---------- MAIN CONTENT ---------- */
    #main-content {
      flex: 1;
      background: #333;
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      overflow: auto;
      border-radius: 8px 0 0 8px;
      height: 100vh;
      -webkit-overflow-scrolling: touch;
      align-content: flex-start;
    }
    html.mobile #main-content {
      flex-direction: column;
      align-items: center;
      flex-wrap: nowrap;
      margin-left: 0;
      border-radius: 0;
      padding-top: 60px;
      height: 100vh;
      overflow-y: scroll;
    }

    /* ---------- PLAYER CONTAINERS ---------- */
    .player-container {
      background: #222;
      display: flex;
      flex-direction: column;
      position: relative; /* Needed for absolute positioning of children */
      box-sizing: border-box;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      flex-shrink: 0;
      /* Add overflow hidden to clip the sidebar */
      overflow: hidden;
    }
    .player-container.desktop {
      width: 960px;
      max-width: 100%;
      margin-bottom: 20px;
    }
    .player-container.mobile {
      margin: 0 auto 20px;
      width: calc(100% - 40px);
      max-width: 480px;
      border-radius: 12px;
      overflow: hidden; /* Already had overflow hidden */
    }
    .player-container.mp4-player .source-video {
      border-radius: 12px 12px 0 0;
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
      min-height: 150px;
      background: #000;
      /* Allow selection for native controls if needed */
      user-select: auto;
      -webkit-user-select: auto;
    }
    .player-container.mp4-player .controls-container {
      background: none;
    }
    .player-container.mp4-player .title-bar {
      border-radius: 0 0 12px 12px;
      border-top: none;
    }

    /* --------- VIDEO & CANVAS --------- */
    .canvas-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      overflow: hidden; /* Keep overflow hidden here too */
      border-radius: 12px 12px 0 0;
      background-color: #000;
      /* Prevent text cursor on canvas */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      cursor: default; /* Default cursor, changes on drag */
    }
    .canvas-wrapper canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Hide the actual <video> in desktop (non-mp4) players */
    .player-container.desktop:not(.mp4-player) .source-video {
      opacity: 0;
      position: absolute;
      top: -9999px;
      left: -9999px;
      width: 1px;
      height: 1px;
      pointer-events: none;
      user-select: none; /* Ensure hidden video isn't selectable */
      -webkit-user-select: none;
    }

    /* Buffering Spinner */
    .buffering-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      transform: translate(-50%, -50%);
      z-index: 15; /* Above canvas, below sidebar */
      display: none; /* Hidden by default */
    }
    .buffering-spinner.visible {
      display: block;
    }
    @keyframes spin {
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }


    /* Native Fullscreen (Desktop) */
    .player-container:fullscreen,
    .player-container:-webkit-full-screen {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      z-index: 2147483647;
      background-color: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden; /* Ensure overflow hidden in fullscreen too */
    }
    .player-container:fullscreen .canvas-wrapper,
    .player-container:-webkit-full-screen .canvas-wrapper {
      width: 100%;
      height: 100%;
      border-radius: 0;
      position: relative;
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    /* Canvas in Fullscreen */
    .player-container:fullscreen .canvas-wrapper canvas,
    .player-container:-webkit-full-screen .canvas-wrapper canvas {
      /* Allow JS to set exact dimensions based on aspect ratio */
      position: absolute; /* Ensure positioning works */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%); /* Center the canvas */
      max-width: 100%; /* Don't exceed container */
      max-height: 100%;
      /* width/height set by JS */
    }

    /* MP4 Video in Fullscreen */
    .player-container.mp4-player:fullscreen .source-video,
    .player-container.mp4-player:-webkit-full-screen .source-video {
      width: 100% !important;
      height: 100% !important;
      object-fit: contain; /* Use contain for native video in fullscreen */
      border-radius: 0;
      min-height: auto;
      aspect-ratio: auto;
    }
    .player-container.mp4-player:fullscreen .controls-container,
    .player-container.mp4-player:-webkit-full-screen .controls-container {
      display: none !important;
    }

    /* ---------- CONTROLS & OVERLAYS ---------- */
    .controls-container {
      position: relative;
      z-index: 2;
      background: #222;
      border-radius: 0 0 12px 12px;
    }
    .control-bar {
      display: flex; align-items: center; gap: 10px; padding: 8px 12px;
    }
    .control-bar button {
      padding: 6px 10px;
      cursor: pointer;
      background-color: #555;
      border: none;
      color: #fff;
      border-radius: 6px;
      font-size: 14px;
      transition: background-color 0.2s;
      flex-shrink: 0;
    }
    .control-bar button:hover { background-color: #666; }
    .progress-bar {
      position: relative;
      flex: 1 1 auto;
      height: 8px;
      background: #555;
      border-radius: 8px;
      overflow: visible;
      margin: 0 10px;
      cursor: pointer;
      min-width: 50px;
    }
    .progress-bar .buffered, .progress-bar .played {
      position: absolute;
      top: 0; bottom: 0; left: 0;
      border-radius: 8px;
      pointer-events: none;
    }
    .progress-bar .buffered { background: #888; width: 0%; opacity: 0.7; }
    .progress-bar .played { background: #4d90fe; width: 0%; z-index: 1; }
    /* Replace existing .progress-bar .thumb rules with these */
    .progress-bar .thumb {
      position: absolute;
      top: 50%;
      left: 0;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      transform: translate(-50%,-50%) scale(0); /* Start scaled down */
      cursor: pointer;
      z-index: 2;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
      opacity: 0; /* Hidden by default */
      transition: opacity 0.2s, transform 0.15s ease-out; /* Smooth transitions */
      pointer-events: none; /* Initially ignore pointer events */
    }
    /* Show slightly when hovering the bar */
    .progress-bar:hover .thumb {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.8);
        pointer-events: auto; /* Enable pointer events on hover */
    }
    /* Show fully when hovering the thumb itself */
    .progress-bar .thumb:hover {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    /* Keep visible while seeking */
    .progress-bar.seeking .thumb {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1); /* Slightly larger while seeking */
        pointer-events: auto;
    }
    .disable-btn { background: #e74c3c; color: #fff; border: none; }
    .disable-btn:hover { background: #c0392b; }
    .title-bar {
      text-align: center;
      padding: 5px 10px;
      font-size: 14px;
      color: #eee;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      background: rgba(0,0,0,0.75);
      border-radius: 0 0 12px 12px;
    }
    .control-bar + .title-bar {
      border-radius: 0;
      border-top: 1px solid #444;
    }

    /* Desktop Controls ONLY in Fullscreen */
    .player-container:not(.mp4-player):fullscreen .controls-container,
    .player-container:not(.mp4-player):-webkit-full-screen .controls-container {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 8px;
      background: rgba(0,0,0,0.75);
      pointer-events: none;
      width: 90%;
      max-width: 800px;
      margin: 0;
      flex-shrink: 0;
    }
    .player-container:not(.mp4-player):fullscreen:hover .controls-container,
    .player-container:not(.mp4-player):-webkit-full-screen:hover .controls-container {
      opacity: 1;
      pointer-events: auto;
    }
    .player-container:not(.mp4-player):fullscreen .title-bar,
    .player-container:not(.mp4-player):-webkit-full-screen .title-bar {
      border-radius: 0 0 8px 8px;
      border-top: 1px solid #444;
    }

    /* ------- URL MODAL & BACKDROP ------- */
    #modalBackdrop {
      display: none;
      position: fixed;
      z-index: 1005;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
    }
    #urlModal {
      display: none;
      position: fixed;
      z-index: 1010;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      width: 90%;
      max-width: 1200px;
      background: #555;
      padding: 25px;
      box-sizing: border-box;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    #urlModal h3 {
      margin-top: 0;
      text-align: center;
      color: #fff;
      margin-bottom: 15px;
    }
    #urlModal textarea {
      width: 100%;
      height: 400px;
      padding: 15px;
      font-size: 14px;
      box-sizing: border-box;
      border-radius: 8px;
      border: 1px solid #666;
      background-color: #f8f8f8;
      color: #333;
      margin-bottom: 15px;
      resize: vertical;
      -webkit-overflow-scrolling: touch;
    }
    #urlModal button { width: auto; padding: 12px 25px; font-size: 16px; display: block; margin: 0 auto; }

    /* ----- MOBILE SIDEBAR ----- */
    html.mobile #urlModal { width: 90vw; max-width: 400px; padding: 15px; font-size: 14px; }
    html.mobile #urlModal textarea { height: 200px; padding: 10px; font-size: 14px; }
    html.mobile #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      height: 100%;
      border-radius: 0 8px 8px 0;
      box-shadow: 3px 0 10px rgba(0,0,0,0.3);
    }
    #sidebarToggle {
      display: none;
      position: fixed;
      top: 20px;
      left: 10px;
      z-index: 1100;
      background: #444;
      border: none;
      width: 40px;
      height: 40px;
      font-size: 20px;
      line-height: 40px;
      text-align: center;
      color: #fff;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    /* ----- MOBILE ROOT SCROLL OVERRIDE ----- */
    html.mobile .container { height: 100vh !important; }
    html.mobile:not(.pseudo-fullscreen-mobile) {
      position: static !important;
      height: auto !important;
      overflow-y: auto !important;
      overflow-x: hidden !important;
    }
    html.mobile:not(.pseudo-fullscreen-mobile) body {
      position: static !important;
      height: auto !important;
      overflow: visible !important;
      min-height: 100vh;
    }
    html.mobile:not(.pseudo-fullscreen-mobile) .container {
      height: auto !important;
      min-height: 100vh !important;
      position: static !important;
      display: block !important;
    }
    html.mobile:not(.pseudo-fullscreen-mobile) #main-content {
      height: auto !important;
      min-height: calc(100vh - 60px);
      overflow: visible !important;
      display: block !important;
    }

    /* ------ MOBILE NON-FULLSCREEN PLAYER ------ */
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .canvas-wrapper,
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .display-canvas {
      display: none !important;
    }
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .controls-container {
      display: block !important;
      position: relative;
      background: #222;
      border-radius: 0 0 12px 12px;
      padding: 0;
    }
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .progress-bar,
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .reset-btn,
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .disable-btn {
      display: none !important;
    }
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .control-bar {
      justify-content: space-between;
      padding: 8px 12px;
      background: none;
    }
    html.mobile .player-container.mobile:not(.player-fullscreen-mobile) .fs-btn-mobile {
      display: inline-block;
    }

    .video-title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      color: #eee;
      font-size: 14px;
      border-bottom: 1px solid #444;
    }
    .fs-btn-mobile {
      cursor: pointer;
      background: none;
      color: #fff;
      border: none;
      padding: 4px 8px;
      font-size: 20px;
      line-height: 1;
      flex-shrink: 0;
    }
    .video-title-row span {
      flex-grow: 1;
      text-align: center;
      margin: 0 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* ---------- MOBILE PSEUDO-FULLSCREEN ---------- */
    html.pseudo-fullscreen-mobile {
      position: relative;
      overflow: hidden !important;
      height: 100vh !important;
    }
    html.pseudo-fullscreen-mobile.non-safari {
      overflow-y: scroll !important;
      height: auto !important;
      min-height: 105vh;
    }
    html.pseudo-fullscreen-mobile body {
      overflow: visible !important;
      height: auto !important;
      position: static !important;
      min-height: 105vh;
    }
    html.pseudo-fullscreen-mobile .container {
      height: auto !important;
      min-height: 105vh;
      position: static !important;
      display: block !important;
    }
    html.pseudo-fullscreen-mobile #main-content {
      height: auto !important;
      min-height: 105vh;
      display: block !important;
    }

    .player-container.player-fullscreen-mobile {
      position: fixed !important;
      top: 0; left: 0;
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
      margin: 0 !important;
      border-radius: 0 !important;
      background-color: #000 !important;
      z-index: 2000 !important;
      overflow: hidden;
    }
    .player-container.player-fullscreen-mobile .source-video {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 0;
      transform-origin: center center;
      transform: scale(1) translate(0px, 0px);
      cursor: grab;
      will-change: transform;
    }
    .player-container.player-fullscreen-mobile .source-video:active {
      cursor: grabbing;
    }
    .player-container.player-fullscreen-mobile .video-title-row,
    .player-container.player-fullscreen-mobile .controls-container:not(.fullscreen-controls) {
      display: none !important;
    }
    .player-container.player-fullscreen-mobile .fullscreen-controls {
      display: block !important;
    }

    .fullscreen-controls {
      display: none;
      position: absolute;
      bottom: -120px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 500px;
      z-index: 2100;
      transition: bottom 0.3s ease-in-out;
      border-radius: 10px;
      background-color: rgba(0, 0, 0, 0.8);
      box-sizing: border-box;
      padding-bottom: env(safe-area-inset-bottom, 10px);
    }
    .player-container.controls-open .fullscreen-controls {
      bottom: 10px;
    }
    .fullscreen-controls .control-bar {
      padding: 10px 15px;
      gap: 15px;
    }
    .fullscreen-controls .progress-bar {
      display: flex !important;
    }

    @media all and (display-mode: standalone) {
      html.mobile body {
        padding-top: env(safe-area-inset-top, 0px);
      }
      html.mobile #sidebarToggle {
        top: calc(20px + env(safe-area-inset-top, 0px));
      }
      html.mobile #main-content {
        padding-top: 60px;
        padding-bottom: env(safe-area-inset-bottom, 0px);
        height: calc(100vh - env(safe-area-inset-top, 0px));
        box-sizing: border-box;
      }
      .player-container.controls-open .fullscreen-controls {
        bottom: env(safe-area-inset-bottom, 10px);
      }
    }

    /* --- Privates Player Overlays (Desktop Only) --- */
    .player-container.desktop .overlay-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .player-container.desktop .overlay-icon:hover {
      opacity: 1;
    }
    .player-container.desktop .right-sidebar {
      position: absolute;
      top: 0;
      right: 0; /* Start position off-screen */
      width: 200px;
      height: 100%;
      background: rgba(50, 50, 50, 0.9);
      z-index: 20;
      transform: translateX(100%); /* Hide by translating */
      transition: transform 0.3s ease;
      padding: 15px;
      box-sizing: border-box;
      color: white;
      overflow-y: auto;
      /* Allow selection within overlay sidebar */
      user-select: auto;
      -webkit-user-select: auto;
      -moz-user-select: auto;
      -ms-user-select: auto;
    }
    .player-container.desktop .right-sidebar.visible {
      transform: translateX(0); /* Show by translating back */
    }
    .player-container.desktop .right-sidebar h4 {
      margin-top: 0;
      margin-bottom: 10px;
      text-align: center;
      border-bottom: 1px solid #666;
      padding-bottom: 5px;
    }
    .player-container.desktop .right-sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .player-container.desktop .right-sidebar li {
      margin-bottom: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .player-container.desktop .right-sidebar input[type="checkbox"] {
      margin-right: 8px;
      cursor: pointer;
    }
    .player-container.desktop .right-sidebar label {
      cursor: pointer;
      flex-grow: 1;
      /* Prevent selection of labels */
      user-select: none;
      -webkit-user-select: none;
    }

    /* Removed old overlay styles */

  </style>

  <script>
    // --- PWA Meta Tag Injection for Safari Mobile ---
    (function() {
      const ua = navigator.userAgent;
      const isSafariMobile = /iPhone|iPad|iPod/.test(ua) && /AppleWebKit/.test(ua) && !/CriOS/.test(ua) && !/FxiOS/.test(ua);
      if (isSafariMobile) {
        const head = document.head;
        let metaCapable = document.createElement('meta');
        metaCapable.name = 'apple-mobile-web-app-capable';
        metaCapable.content = 'yes';
        head.appendChild(metaCapable);
        let metaStatusBarStyle = document.createElement('meta');
        metaStatusBarStyle.name = 'apple-mobile-web-app-status-bar-style';
        metaStatusBarStyle.content = 'black-translucent';
        head.appendChild(metaStatusBarStyle);
        let metaTitle = document.createElement('meta');
        metaTitle.name = 'apple-mobile-web-app-title';
        metaTitle.content = 'Live DVR';
        head.appendChild(metaTitle);
        console.log("Safari Mobile detected: Added PWA meta tags.");
      }
    })();

    const IS_MOBILE = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
    const IS_SAFARI_MOBILE = IS_MOBILE && /iPhone|iPad|iPod/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/CriOS/.test(navigator.userAgent) && !/FxiOS/.test(navigator.userAgent);
    if (IS_MOBILE) {
      document.documentElement.classList.add("mobile");
      if (IS_SAFARI_MOBILE) document.documentElement.classList.add("safari-mobile");
      else document.documentElement.classList.add("non-safari-mobile");
    }

    let spaceHeld = false;
    window.addEventListener("keydown", e => {
      if (e.code === "Space" && !["input","textarea","button"].includes(document.activeElement.tagName.toLowerCase())) {
        e.preventDefault();
        spaceHeld = true;
      }
    });
    window.addEventListener("keyup", e => {
      if (e.code === "Space") spaceHeld = false;
    });

    let cursorTimeout;
    function showCursor() { document.body.style.cursor = ""; }
    function hideCursor() { document.body.style.cursor = "none"; }
    document.addEventListener("fullscreenchange", () => {
      if (document.fullscreenElement) {
        showCursor();
        clearTimeout(cursorTimeout);
        cursorTimeout = setTimeout(hideCursor, 3000);
      } else {
        showCursor();
        clearTimeout(cursorTimeout);
      }
    });
    document.addEventListener("mousemove", () => {
      if (document.fullscreenElement) {
        showCursor();
        clearTimeout(cursorTimeout);
        cursorTimeout = setTimeout(hideCursor, 3000);
      }
    });

    function hideBrowserUI() {
      if (!window.matchMedia('(display-mode: standalone)').matches && !IS_SAFARI_MOBILE) {
        setTimeout(() => {
          const htmlScrollable = document.documentElement.scrollHeight > document.documentElement.clientHeight;
          if (htmlScrollable) document.documentElement.scrollTop = 1;
          else window.scrollTo(0,1);
        }, 300);
      }
    }
  </script>
</head>
<body>
  <button id="sidebarToggle">&#x2630;</button>
  <div class="container">
    <div id="sidebar">
      <button id="btn-add-urls">Add URLs</button>
      <div id="sideButtons">
        <button id="btn-show-all" class="sideBtn">Show All</button>
        <button id="btn-hide-all" class="sideBtn">Hide All</button>
      </div>
      <div id="streamList">
        <p class="no-streams">Loading streams...</p>
      </div>
    </div>
    <div id="main-content"></div>
  </div>
  <div id="modalBackdrop"></div>
  <div id="urlModal">
    <h3>Paste Playlist URLs (one per line)</h3>
    <textarea id="urlInput" placeholder="https://…/playlist.m3u8"></textarea>
    <button id="saveUrls">Save and Close</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    function enterNativeFullScreen(el) {
      if (document.fullscreenElement || document.webkitFullscreenElement) return Promise.resolve();
      const r = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
      if (r) return r.call(el).catch(err => console.error("Native Fullscreen request failed:", err));
      else return Promise.reject("Native Fullscreen not supported");
    }
    function exitNativeFullScreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) return Promise.resolve();
      const e = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
      if (e) return e.call(document).catch(err => console.error("Exit Native Fullscreen failed:", err));
      else return Promise.reject("Exit Native Fullscreen not supported");
    }

    const PROXY_PREFIX = "https://surfcam-alpha.vercel.app/api/proxy?url=";
    const PLAYER_SETTINGS_KEY = "liveDvrPlayerSettings_v1";
    const STREAM_CONFIGS_KEY = "liveDvrStreamConfigs_v1";

    function loadPlayerSettings(url) {
      try {
        const all = JSON.parse(localStorage.getItem(PLAYER_SETTINGS_KEY) || "{}");
        return all[url] || { zoomScale: 1, panX: 0, panY: 0 };
      } catch {
        return { zoomScale: 1, panX: 0, panY: 0 };
      }
    }
    function savePlayerSettings(url, data) {
      try {
        let all = JSON.parse(localStorage.getItem(PLAYER_SETTINGS_KEY) || "{}");
        all[url] = data;
        localStorage.setItem(PLAYER_SETTINGS_KEY, JSON.stringify(all));
      } catch {}
    }
    function getStreamList() {
      try {
        const stored = localStorage.getItem(STREAM_CONFIGS_KEY);
        if (!stored) return [];
        const parsed = JSON.parse(stored);
        if (!Array.isArray(parsed) || !parsed.every(i => typeof i === 'object' && 'url' in i && 'enabled' in i)) {
          localStorage.removeItem(STREAM_CONFIGS_KEY);
          return [];
        }
        return parsed;
      } catch {
        localStorage.removeItem(STREAM_CONFIGS_KEY);
        return [];
      }
    }
    function saveStreamList(list) {
      try {
        if (!Array.isArray(list) || !list.every(i => typeof i === 'object' && 'url' in i && 'enabled' in i)) return;
        localStorage.setItem(STREAM_CONFIGS_KEY, JSON.stringify(list));
      } catch {}
    }

    function extractTitle(url) {
      const m = url.match(/wc-([^\/]+)\/playlist/);
      return m ? m[1] : url;
    }
    // Helper to create safe IDs for elements
    function createSafeId(prefix, url) {
      // Basic encoding + replace characters not allowed in CSS selectors/IDs
      return `${prefix}-${encodeURIComponent(url).replace(/[.%*+?^${}()|[\]\\]/g,'_')}`;
    }
    // Modify clampPan to accept canvas and use its dimensions
    function clampPan(container, canvas) { // Added canvas argument
      const Z = container.zoomScale;
      // Use actual canvas dimensions
      const W = canvas.width;
      const H = canvas.height;
      if (Z <= 1) {
        container.panX = 0;
        container.panY = 0;
        return;
      }
      // Calculate max pan distance based on zoom and current canvas size
      const mx = (W * (Z - 1)) / (2 * Z);
      const my = (H * (Z - 1)) / (2 * Z);
      container.panX = Math.min(mx, Math.max(-mx, container.panX));
      container.panY = Math.min(my, Math.max(-my, container.panY));
    }
    function getTouchDistance(t1, t2) {
      const dx = t1.clientX - t2.clientX;
      const dy = t1.clientY - t2.clientY;
      return Math.hypot(dx, dy);
    }
    function getTouchMidpoint(t1, t2) {
      return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
    }

    const sidebar = document.getElementById("sidebar");
    const sidebarToggle = document.getElementById("sidebarToggle");
    const streamListContainer = document.getElementById("streamList");
    const mainContent = document.getElementById("main-content");
    const modalBackdrop = document.getElementById("modalBackdrop");
    const urlModal = document.getElementById("urlModal");
    const urlInput = document.getElementById("urlInput");
    const saveUrlsBtn = document.getElementById("saveUrls");
    const btnAddUrls = document.getElementById("btn-add-urls");
    const btnShowAll = document.getElementById("btn-show-all");
    const btnHideAll = document.getElementById("btn-hide-all");

    let activeSidebarLabels = new Set();
    let sidebarDragStartState = null;
    let isSidebarDragging = false;
    let players = {}; // Store player instances { url: { container, video, hls, animationFrameId, overlays?, offscreenCanvas?, isBuffering?, ... } }

    function updateStreamSidebar() {
      streamListContainer.innerHTML = "";
      const streams = getStreamList();
      if (!streams.length) {
        const p = document.createElement("p");
        p.className = "no-streams";
        p.textContent = "No streams added. Click 'Add URLs'.";
        streamListContainer.appendChild(p);
      } else {
        streams.forEach(stream => {
          const item = document.createElement("div");
          item.className = "stream-item";
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = stream.enabled;
          checkbox.dataset.url = stream.url;
          // Use createSafeId for checkbox ID
          checkbox.id = createSafeId('cb', stream.url);
          checkbox.addEventListener("change", e => {
            updateStreamEnabled(stream.url, e.target.checked);
          });
          item.appendChild(checkbox);
          const label = document.createElement("label");
          label.textContent = extractTitle(stream.url);
          // Use createSafeId for label's htmlFor
          label.htmlFor = checkbox.id;
          label.dataset.url = stream.url;
          label.addEventListener("mousedown", e => {
            if (e.button === 0) {
              e.preventDefault();
              isSidebarDragging = true;
              sidebarDragStartState = checkbox.checked;
              activeSidebarLabels.clear();
              activeSidebarLabels.add(label);
              item.classList.add('selecting');
            }
          });
          label.addEventListener("mouseenter", e => {
            if (isSidebarDragging && (e.buttons & 1)) {
              activeSidebarLabels.add(label);
              item.classList.add('selecting');
            }
          });
          item.appendChild(label);
          streamListContainer.appendChild(item);
        });
      }
    }
    document.addEventListener("mouseup", e => {
      if (e.button === 0 && isSidebarDragging) {
        isSidebarDragging = false;
        const labelsToToggle = new Set(activeSidebarLabels);
        activeSidebarLabels.clear();
        document.querySelectorAll('.stream-item.selecting').forEach(el => el.classList.remove('selecting'));
        if (labelsToToggle.size) {
          const targetState = !sidebarDragStartState;
          labelsToToggle.forEach(label => {
            const url = label.dataset.url;
            // Use createSafeId to find the checkbox
            const cb = document.getElementById(createSafeId('cb', url));
            if (cb) {
              cb.checked = targetState;
              updateStreamEnabled(url, targetState);
            }
          });
        }
        sidebarDragStartState = null;
      }
    });
    streamListContainer.addEventListener('contextmenu', e => {
      if (isSidebarDragging) e.preventDefault();
    });

    function reorderPlayers() {
      const streams = getStreamList();
      const sorted = Array.from(mainContent.children)
        .filter(el => el.classList.contains('player-container'))
        .sort((a,b) => {
          const iA = streams.findIndex(s => s.url === a.dataset.url);
          const iB = streams.findIndex(s => s.url === b.dataset.url);
          if (iA === -1) return 1;
          if (iB === -1) return -1;
          return iA - iB;
        });
      sorted.forEach(el => mainContent.appendChild(el));
    }
    function updateStreamEnabled(url, enabled) {
      let streams = getStreamList();
      const idx = streams.findIndex(s => s.url === url);
      if (idx === -1) return;
      streams[idx].enabled = enabled;
      saveStreamList(streams);
      const existing = players[url];
      if (enabled) {
        if (!existing) {
          const built = createPlayerContainer(streams[idx]);
          if (built) {
            mainContent.appendChild(built.container);
            players[url] = built; // Store the built player object
          }
        } else {
          if (!existing.container.isConnected) mainContent.appendChild(existing.container);
          existing.container.style.display = "flex";
          if (existing.hls && !existing.hls.media) existing.hls.attachMedia(existing.video);
          if (existing.hls) existing.hls.startLoad();
          else if (existing.video.src && existing.video.paused) existing.video.play().catch(()=>{});
          // Ensure video plays if autoplay is intended or if it was playing before being hidden
          if (existing.video.autoplay || !existing.video.paused) existing.video.play().catch(()=>{});
        }
      } else {
        if (existing) {
          // Remove fullscreen listener before destroying player
          if (existing.resizeHandler) {
              document.removeEventListener("fullscreenchange", existing.resizeHandler);
              document.removeEventListener("webkitfullscreenchange", existing.resizeHandler);
              window.removeEventListener("resize", existing.resizeHandler); // Also remove window resize listener
              existing.resizeHandler = null; // Clear reference
          }
          if (existing.hls) existing.hls.destroy();
          existing.video.pause();
          existing.video.removeAttribute('src');
          existing.video.load();
          if (existing.animationFrameId) cancelAnimationFrame(existing.animationFrameId);
          existing.animationFrameId = null; // Explicitly nullify
          // Clean up offscreen canvas if it exists
          if (existing.offscreenCanvas) {
              existing.offscreenCanvas.width = 0; // Release memory
              existing.offscreenCanvas = null;
          }
          if (existing.container.classList.contains('player-fullscreen-mobile')) {
            exitPseudoFullscreen(existing.container, existing.video);
          }
          existing.container.remove();
          delete players[url];
        }
      }
      reorderPlayers();
      updateStreamSidebar(); // Update sidebar to reflect checkbox state
    }

    // Function to handle canvas resizing on fullscreen change or window resize
    function resizeCanvas(playerObj) {
        if (!playerObj || !playerObj.canvas || !playerObj.container) return;

        const canvas = playerObj.canvas;
        const wrapper = playerObj.container.querySelector('.canvas-wrapper');
        const isFs = document.fullscreenElement === playerObj.container || document.webkitFullscreenElement === playerObj.container;

        let targetWidth, targetHeight;

        if (isFs) {
            targetWidth = wrapper.clientWidth;
            targetHeight = wrapper.clientHeight;
        } else {
            // Use default non-fullscreen size or calculate based on container?
            // Sticking to fixed size for now when not fullscreen.
            targetWidth = 960;
            targetHeight = 540;
        }

        // Only resize if dimensions actually changed
        if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
            canvas.width = targetWidth;
            canvas.height = targetHeight;

            // Resize offscreen canvas too
            if (playerObj.offscreenCanvas) {
                playerObj.offscreenCanvas.width = targetWidth;
                playerObj.offscreenCanvas.height = targetHeight;
            }
            console.log(`Resized canvas for ${playerObj.container.dataset.url} to ${targetWidth}x${targetHeight}`);

            // Trigger a redraw if the animation loop isn't running
            if (!playerObj.animationFrameId && playerObj.container.isConnected) {
                renderCanvas(playerObj.overlays); // Assuming renderCanvas is accessible
            }
        }
    }


    function createPlayerContainer(stream) {
      if (!stream || !stream.enabled) return null;
      const url = stream.url;
      const saved = loadPlayerSettings(url);
      const container = document.createElement("div");
      container.className = `player-container ${IS_MOBILE?"mobile":"desktop"}`;
      container.dataset.url = url;
      // Initialize pan/zoom state on the container object
      container.zoomScale = saved.zoomScale;
      container.panX = saved.panX;
      container.panY = saved.panY;

      const video = document.createElement("video");
      video.className = "source-video";
      video.setAttribute("playsinline","");
      video.setAttribute("webkit-playsinline","");
      video.setAttribute("crossorigin","anonymous"); // Needed for canvas drawing
      video.muted = true; // Mute by default, especially for HLS/Canvas
      video.preload = "metadata";
      video.autoplay = true; // Autoplay often needed for live streams

      let hlsInstance = null;
      let animationFrameId = null;
      const isMp4 = url.toLowerCase().endsWith('.mp4');
      const title = extractTitle(url);

      // --- Player object to be returned ---
      // Define it here so we can add properties like overlays, offscreenCanvas later
      const playerObject = {
          container,
          video,
          hls: hlsInstance,
          animationFrameId: null,
          overlays: null,        // Will hold overlay state if applicable
          offscreenCanvas: null, // Will hold the offscreen canvas for masking
          offscreenCtx: null,    // Context for the offscreen canvas
          isBuffering: false,    // Flag for buffering state
          canvas: null,          // Reference to the main canvas
          resizeHandler: null    // Reference to the resize handler function
      };


      if (isMp4) {
        // --- MP4 Player Setup (Desktop & Mobile) ---
        container.classList.add('mp4-player');
        video.controls = true; // Use native controls for MP4
        video.muted = false; // Allow sound for MP4
        video.autoplay = false; // Don't autoplay MP4 typically
        // Conditionally use proxy
        video.src = IS_MOBILE ? PROXY_PREFIX + encodeURIComponent(url) : url;
        container.appendChild(video);

        // Add a simple title bar below the video
        const ctr = document.createElement("div");
        ctr.className = "controls-container"; // Reuse styling if needed
        const tb = document.createElement("div");
        tb.className = "title-bar";
        tb.textContent = title;
        ctr.appendChild(tb);
        container.appendChild(ctr);

        // Basic error handling
        video.addEventListener('error', e => {
          console.error(`Error loading MP4: ${url}`, video.error);
          tb.textContent = `Error: ${video.error?.message || 'Could not load video'}`;
          tb.style.color = 'red';
        });

        // Fullscreen handling (different for mobile/desktop)
        if (IS_MOBILE) {
          // Mobile: Double-tap for pseudo-fullscreen
          let lastTap = 0;
          container.addEventListener("click", e => {
            // Ignore clicks on controls
            if (e.target.closest('video[controls]')) return;
            const now = Date.now();
            if (now - lastTap < 350) { // Double tap threshold
              enterPseudoFullscreen(container, video);
              lastTap = 0; // Reset tap timer
            } else {
              lastTap = now;
            }
          });
        } else {
          // Desktop: Double-tap for native fullscreen
          let lastTap = 0;
          container.addEventListener("click", e => {
            // Ignore clicks on controls
            if (e.target.closest('video[controls]')) return;
            const now = Date.now();
            if (now - lastTap < 300) { // Double tap threshold
              if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                enterNativeFullScreen(container);
              } else {
                exitNativeFullScreen();
              }
              lastTap = 0; // Reset tap timer
            } else {
              lastTap = now;
            }
          });
        }
      } else if (IS_MOBILE) {
        // --- Mobile HLS Player Setup (Native Video Element) ---
        // Title row with fullscreen button
        const titleRow = document.createElement("div");
        titleRow.className = "video-title-row";
        const titleSpan = document.createElement("span");
        titleSpan.textContent = title;
        const fsBtnMobile = document.createElement("button");
        fsBtnMobile.className = "fs-btn-mobile";
        fsBtnMobile.innerHTML = "&#x26F6;"; // Fullscreen symbol
        fsBtnMobile.setAttribute("aria-label","Enter Fullscreen");
        titleRow.appendChild(titleSpan);
        titleRow.appendChild(fsBtnMobile);
        container.appendChild(titleRow);

        // Video element itself
        container.appendChild(video);

        // Simple controls (Play/Pause) below the video
        const ctrM = document.createElement("div");
        ctrM.className = "controls-container";
        const cbM = document.createElement("div");
        cbM.className = "control-bar";
        const ppM = document.createElement("button");
        ppM.textContent = "Play";
        ppM.setAttribute("aria-label","Play/Pause");
        cbM.appendChild(ppM);
        ctrM.appendChild(cbM);
        container.appendChild(ctrM);

        // Mobile interaction: Tap to play/pause, Double-tap for fullscreen
        let lastTap = 0;
        container.addEventListener("click", e => {
          // Ignore clicks on controls
          if (e.target.closest('.controls-container') || e.target.closest('.video-title-row')) return;
          const now = Date.now();
          const dt = now - lastTap;
          if (dt < 350) { // Double tap
            enterPseudoFullscreen(container, video);
            lastTap = 0;
          } else { // Single tap
            if (video.paused) video.play().catch(()=>{});
            else video.pause();
            lastTap = now;
          }
        });

        // Play/Pause button action
        ppM.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click handler
          if (video.paused) video.play().catch(()=>{});
          else video.pause();
        });

        // Fullscreen button action
        fsBtnMobile.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click handler
          enterPseudoFullscreen(container, video);
        });

        // Update Play/Pause button text based on video state
        video.addEventListener("play", () => ppM.textContent = "Pause");
        video.addEventListener("pause", () => ppM.textContent = "Play");
        video.addEventListener("ended", () => ppM.textContent = "Play");

        // Attempt to autoplay when ready
        video.addEventListener('canplay', () => {
          if (video.paused) { // Only play if currently paused
             video.play().catch(e => console.log(`Autoplay failed for ${url}:`, e));
          }
        }, { once: true }); // Only run once

      } else {
        // --- Desktop HLS Player Setup (Canvas Rendering) ---
        const canvasWrapper = document.createElement("div");
        canvasWrapper.className = "canvas-wrapper";
        container.appendChild(canvasWrapper);

        const canvas = document.createElement("canvas");
        canvas.className = "display-canvas";
        canvas.width = 960; // Initial base resolution
        canvas.height = 540;
        canvasWrapper.appendChild(canvas);
        playerObject.canvas = canvas; // Store canvas reference

        // Add Buffering Spinner Element
        const spinner = document.createElement('div');
        spinner.className = 'buffering-spinner';
        canvasWrapper.appendChild(spinner); // Add spinner inside the wrapper

        // Create offscreen canvas for masking operations
        playerObject.offscreenCanvas = document.createElement('canvas');
        playerObject.offscreenCanvas.width = canvas.width;
        playerObject.offscreenCanvas.height = canvas.height;
        playerObject.offscreenCtx = playerObject.offscreenCanvas.getContext('2d');

        // Add buffering state and previous time tracker
        playerObject.isBuffering = false;
        playerObject.previousTime = 0;


        const controlsContainer = document.createElement("div");
        controlsContainer.className = "controls-container";
        container.appendChild(controlsContainer);

        // Initialize overlays state for this player instance
        let currentOverlays = null; // Use a different name to avoid confusion
        let rightSidebar = null; // Define here for access in click handler

        /* --- Privates Overlays Setup (Canvas-based) --- */
        // ... (overlay setup code remains the same) ...
        if (title === 'privates') {
          const overlayIcon = document.createElement('button');
          overlayIcon.className = 'overlay-icon';
          overlayIcon.innerHTML = '⚙️'; // Gear icon
          overlayIcon.title = 'Spot Overlays';
          canvasWrapper.appendChild(overlayIcon); // Add icon to canvas wrapper

          // Assign to the outer scope variable
          rightSidebar = document.createElement('div');
          rightSidebar.className = 'right-sidebar';
          // Use createSafeId for unique IDs within this player
          rightSidebar.innerHTML = `
            <h4>Spot Features</h4>
            <ul>
              <li><input type="checkbox" id="${createSafeId('cb-pp', url)}" data-spot="pp"><label for="${createSafeId('cb-pp', url)}">Pleasure Point</label></li>
              <li><input type="checkbox" id="${createSafeId('cb-jacks', url)}" data-spot="jacks"><label for="${createSafeId('cb-jacks', url)}">Jack's</label></li>
              <li><input type="checkbox" id="${createSafeId('cb-hook', url)}" data-spot="hook"><label for="${createSafeId('cb-hook', url)}">The Hook</label></li>
              <li><input type="checkbox" id="${createSafeId('cb-sharks', url)}" data-spot="sharks"><label for="${createSafeId('cb-sharks', url)}">Sharks</label></li>
              <li><input type="checkbox" id="${createSafeId('cb-ib', url)}" data-spot="ib"><label for="${createSafeId('cb-ib', url)}">In-betweens</label></li>
              <li><input type="checkbox" id="${createSafeId('cb-privates', url)}" data-spot="privates"><label for="${createSafeId('cb-privates', url)}">Privates</label></li>
            </ul>`;
          container.appendChild(rightSidebar); // Add sidebar to main container

          // --- Preload images for canvas ---
          const BASE_OVERLAY_URL = "https://devenf23.github.io/surfcam/privates/";
          // Jack's
          const jacksMinorImg = new Image(); jacksMinorImg.src = `${BASE_OVERLAY_URL}Jack's/Jack's_minor.png`;
          const jacksTextImg = new Image(); jacksTextImg.src = `${BASE_OVERLAY_URL}Jack's/Jack's_text.png`;
          const jacksMaskImg = new Image(); jacksMaskImg.src = `${BASE_OVERLAY_URL}Jack's/Jack's_major.png`;
          // Pleasure Point
          const ppMinorImg = new Image(); ppMinorImg.src = `${BASE_OVERLAY_URL}pp/pp_minor.png`;
          const ppTextImg = new Image(); ppTextImg.src = `${BASE_OVERLAY_URL}pp/pp_text.png`;
          const ppMaskImg = new Image(); ppMaskImg.src = `${BASE_OVERLAY_URL}pp/pp_major.png`;
          // Hook
          const hookMinorImg = new Image(); hookMinorImg.src = `${BASE_OVERLAY_URL}hook/hook_minor.png`;
          const hookTextImg = new Image(); hookTextImg.src = `${BASE_OVERLAY_URL}hook/hook_text.png`;
          const hookMaskImg = new Image(); hookMaskImg.src = `${BASE_OVERLAY_URL}hook/hook_major.png`;
          // Sharks
          const sharksMinorImg = new Image(); sharksMinorImg.src = `${BASE_OVERLAY_URL}sharks/sharks_minor.png`;
          const sharksTextImg = new Image(); sharksTextImg.src = `${BASE_OVERLAY_URL}sharks/sharks_text.png`;
          const sharksMaskImg = new Image(); sharksMaskImg.src = `${BASE_OVERLAY_URL}sharks/sharks_major.png`;
          // In-betweens (ib)
          const ibMinorImg = new Image(); ibMinorImg.src = `${BASE_OVERLAY_URL}ib/ib_minor.png`;
          const ibTextImg = new Image(); ibTextImg.src = `${BASE_OVERLAY_URL}ib/ib_text.png`;
          const ibMaskImg = new Image(); ibMaskImg.src = `${BASE_OVERLAY_URL}ib/ib_major.png`;
          // Privates (spot)
          const privatesMinorImg = new Image(); privatesMinorImg.src = `${BASE_OVERLAY_URL}privates/privates_minor.png`;
          const privatesTextImg = new Image(); privatesTextImg.src = `${BASE_OVERLAY_URL}privates/privates_text.png`;
          const privatesMaskImg = new Image(); privatesMaskImg.src = `${BASE_OVERLAY_URL}privates/privates_major.png`;


          // --- Track which overlays to draw ---
          currentOverlays = {
            // Jack's
            jacks_mask: false, jacks_minor: false, jacks_text: false,
            imgJacksMask: jacksMaskImg, imgJacksMinor: jacksMinorImg, imgJacksText: jacksTextImg,
            // Pleasure Point
            pp_mask: false, pp_minor: false, pp_text: false,
            imgPpMask: ppMaskImg, imgPpMinor: ppMinorImg, imgPpText: ppTextImg,
            // Hook
            hook_mask: false, hook_minor: false, hook_text: false,
            imgHookMask: hookMaskImg, imgHookMinor: hookMinorImg, imgHookText: hookTextImg,
            // Sharks
            sharks_mask: false, sharks_minor: false, sharks_text: false,
            imgSharksMask: sharksMaskImg, imgSharksMinor: sharksMinorImg, imgSharksText: sharksTextImg,
            // In-betweens
            ib_mask: false, ib_minor: false, ib_text: false,
            imgIbMask: ibMaskImg, imgIbMinor: ibMinorImg, imgIbText: ibTextImg,
            // Privates (spot)
            privates_mask: false, privates_minor: false, privates_text: false,
            imgPrivatesMask: privatesMaskImg, imgPrivatesMinor: privatesMinorImg, imgPrivatesText: privatesTextImg,
          };
          playerObject.overlays = currentOverlays; // Add state to the player object

          // --- Toggle the sidebar ---
          overlayIcon.addEventListener('click', e => {
            e.stopPropagation();
            rightSidebar.classList.toggle('visible');
          });

          // --- Hook the checkboxes ---
          const setupCheckboxListener = (spotPrefix) => {
              // Use the data-spot attribute to find the checkbox
              const checkbox = rightSidebar.querySelector(`input[data-spot="${spotPrefix}"]`);
              if (checkbox) {
                  checkbox.addEventListener('change', e => {
                      const on = e.target.checked;
                      if (currentOverlays) {
                          // Use the spotPrefix directly to update state properties
                          currentOverlays[`${spotPrefix}_mask`] = on;
                          currentOverlays[`${spotPrefix}_minor`] = on;
                          currentOverlays[`${spotPrefix}_text`] = on;
                      }
                  });
              } else {
                  console.error(`Could not find ${spotPrefix} checkbox`);
              }
          };

          setupCheckboxListener('pp');
          setupCheckboxListener('jacks');
          setupCheckboxListener('hook');
          setupCheckboxListener('sharks');
          setupCheckboxListener('ib');
          setupCheckboxListener('privates');


          // Close sidebar if clicking outside
          container.addEventListener('click', e => {
            // Check if the sidebar exists and is visible
            if (rightSidebar && rightSidebar.classList.contains('visible')) {
              // Check if the click was outside the sidebar and not on the toggle icon
              if (!rightSidebar.contains(e.target) && e.target !== overlayIcon) {
                rightSidebar.classList.remove('visible');
                // Prevent the click from bubbling up and potentially pausing video
                e.preventDefault(); // Prevent default action (like text selection)
                e.stopPropagation(); // Stop the event from reaching the main click handler
              }
            }
          }, true); // Use capture phase to catch the click early

        }
        /* --- end privates overlays setup --- */

        // Append video element (hidden by CSS, used as source for canvas)
        container.appendChild(video);

        const mainCtx = canvas.getContext("2d"); // Context for visible canvas
        const offscreenCtx = playerObject.offscreenCtx; // Context for offscreen canvas

        // --- Buffering Listeners ---
        // We will handle spinner visibility primarily in updateProgressBar based on stall detection
        // video.addEventListener('waiting', () => { ... }); // Removed
        // video.addEventListener('playing', () => { ... }); // Removed
        // video.addEventListener('canplay', () => { ... }); // Removed

        // --- Canvas Rendering Loop ---
        function renderCanvas(overlayState) {
          // Check if the container is still connected to the DOM
          if (!container.isConnected) {
              if (playerObject.animationFrameId) {
                  cancelAnimationFrame(playerObject.animationFrameId);
                  playerObject.animationFrameId = null;
              }
              return; // Stop rendering if disconnected
          }

          // Use the player object's buffering flag
          const isBuffering = playerObject.isBuffering;

          // Apply pan limits using the current canvas dimensions
          clampPan(container, canvas);

          let drawWidth, drawHeight, offsetX, offsetY;
          // Use the canvas's current drawing surface size
          let actualCanvasWidth = canvas.width;
          let actualCanvasHeight = canvas.height;

          if (video.videoWidth > 0 && video.videoHeight > 0) {
              // Calculate drawing dimensions based on *canvas drawing surface size*
              const canvasAspect = actualCanvasWidth / actualCanvasHeight;
              const videoAspect = video.videoWidth / video.videoHeight;
              if (canvasAspect > videoAspect) { // Canvas wider than video -> pillarbox
                  drawHeight = actualCanvasHeight;
                  drawWidth = drawHeight * videoAspect;
                  offsetX = (actualCanvasWidth - drawWidth) / 2;
                  offsetY = 0;
              } else { // Canvas taller than video (or same aspect) -> letterbox
                  drawWidth = actualCanvasWidth;
                  drawHeight = drawWidth / videoAspect;
                  offsetX = 0;
                  offsetY = (actualCanvasHeight - drawHeight) / 2;
              }
          } else {
              // Video dimensions not ready, show loading and request next frame
              mainCtx.save();
              mainCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
              mainCtx.fillStyle = '#555';
              mainCtx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight); // Clear with loading background
              mainCtx.fillStyle = '#fff';
              mainCtx.textAlign = 'center';
              mainCtx.font = '16px Arial';
              mainCtx.fillText('Loading...', actualCanvasWidth / 2, actualCanvasHeight / 2);
              mainCtx.restore();
              playerObject.animationFrameId = requestAnimationFrame(() => renderCanvas(overlayState));
              return;
          }

          mainCtx.save();
          // Clear the main canvas only if not buffering (to keep last frame)
          if (!isBuffering) {
              mainCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform before clearing
              mainCtx.fillStyle = '#000';
              mainCtx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);
          }

          // Apply pan/zoom transformations centered on the *actual* canvas size
          const centerX = actualCanvasWidth / 2;
          const centerY = actualCanvasHeight / 2;
          mainCtx.translate(centerX, centerY);
          mainCtx.scale(container.zoomScale, container.zoomScale);
          mainCtx.translate(container.panX, container.panY);
          mainCtx.translate(-centerX, -centerY);

          try {
              // 1. Draw the video frame *only if not buffering*
              if (!isBuffering) {
                  mainCtx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
              }
              // Else: the previous frame remains on the canvas

              // 2. Check if any mask needs to be applied
              const activeMasks = [];
              if (overlayState) {
                  const isMaskReady = (prefix) => overlayState[`${prefix}_mask`] && overlayState[`img${prefix.charAt(0).toUpperCase() + prefix.slice(1)}Mask`]?.complete && overlayState[`img${prefix.charAt(0).toUpperCase() + prefix.slice(1)}Mask`].naturalWidth > 0;
                  if (isMaskReady('jacks')) activeMasks.push(overlayState.imgJacksMask);
                  if (isMaskReady('pp')) activeMasks.push(overlayState.imgPpMask);
                  if (isMaskReady('hook')) activeMasks.push(overlayState.imgHookMask);
                  if (isMaskReady('sharks')) activeMasks.push(overlayState.imgSharksMask);
                  if (isMaskReady('ib')) activeMasks.push(overlayState.imgIbMask);
                  if (isMaskReady('privates')) activeMasks.push(overlayState.imgPrivatesMask);
              }


              if (activeMasks.length > 0 && offscreenCtx) {
                  // --- Prepare masked video on offscreen canvas (only if not buffering) ---
                  if (!isBuffering) {
                      // Ensure offscreen canvas matches main canvas size if it changed (e.g., fullscreen)
                      if (playerObject.offscreenCanvas.width !== actualCanvasWidth || playerObject.offscreenCanvas.height !== actualCanvasHeight) {
                          playerObject.offscreenCanvas.width = actualCanvasWidth;
                          playerObject.offscreenCanvas.height = actualCanvasHeight;
                      }
                      offscreenCtx.save();
                      offscreenCtx.clearRect(0, 0, actualCanvasWidth, actualCanvasHeight);
                      offscreenCtx.globalCompositeOperation = 'source-over';
                      activeMasks.forEach((maskImg, index) => {
                          if (index > 0) offscreenCtx.globalCompositeOperation = 'lighter';
                          // Draw mask using calculated dimensions
                          offscreenCtx.drawImage(maskImg, offsetX, offsetY, drawWidth, drawHeight);
                      });
                      offscreenCtx.globalCompositeOperation = 'source-in';
                      // Draw video using calculated dimensions
                      offscreenCtx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
                      offscreenCtx.restore();
                  }
                  // --- Draw onto main canvas ---
                  // Always draw darkening layer if mask is active
                  mainCtx.fillStyle = 'rgba(0,0,0,0.4)';
                  mainCtx.fillRect(offsetX, offsetY, drawWidth, drawHeight);
                  // Draw the clipped video from offscreen canvas over the darkening layer
                  // Use the actual canvas dimensions for the destination draw
                  mainCtx.drawImage(playerObject.offscreenCanvas, 0, 0, actualCanvasWidth, actualCanvasHeight, 0, 0, actualCanvasWidth, actualCanvasHeight);
              }

              // 3. Draw minor/text overlays on top (if enabled) - on main canvas
              if (overlayState) {
                  const drawOverlay = (prefix) => {
                      const minorFlag = overlayState[`${prefix}_minor`];
                      const textFlag = overlayState[`${prefix}_text`];
                      const minorImg = overlayState[`img${prefix.charAt(0).toUpperCase() + prefix.slice(1)}Minor`];
                      const textImg = overlayState[`img${prefix.charAt(0).toUpperCase() + prefix.slice(1)}Text`];
                      if (minorFlag && minorImg?.complete && minorImg.naturalWidth > 0) {
                          mainCtx.drawImage(minorImg, offsetX, offsetY, drawWidth, drawHeight);
                      }
                      if (textFlag && textImg?.complete && textImg.naturalWidth > 0) {
                          mainCtx.drawImage(textImg, offsetX, offsetY, drawWidth, drawHeight);
                      }
                  };
                  drawOverlay('jacks');
                  drawOverlay('pp');
                  drawOverlay('hook');
                  drawOverlay('sharks');
                  drawOverlay('ib');
                  drawOverlay('privates');
              }

          } catch (e) {
              console.error("Canvas Draw Error:", e);
              // Draw error message without transforms
              mainCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
              mainCtx.fillStyle = 'red';
              mainCtx.textAlign = 'center';
              mainCtx.fillText('Render Error', actualCanvasWidth / 2, actualCanvasHeight / 2);
          }

          mainCtx.restore(); // Restore main canvas context (removes pan/zoom)

          // Continue animation loop
          playerObject.animationFrameId = requestAnimationFrame(() => renderCanvas(overlayState));
        }


        // Start rendering when video can play
        video.addEventListener("canplay", () => {
          // Check if already rendering and container is connected
          if (!playerObject.animationFrameId && container.isConnected) {
             renderCanvas(currentOverlays); // Start the loop, passing initial overlay state
          }
        });

        // Stop rendering if video becomes empty or errors
        video.addEventListener('emptied', () => {
          if (playerObject.animationFrameId) cancelAnimationFrame(playerObject.animationFrameId);
          playerObject.animationFrameId = null;
        });
        video.addEventListener('error', () => {
          if (playerObject.animationFrameId) cancelAnimationFrame(playerObject.animationFrameId);
          playerObject.animationFrameId = null;
          // Optionally clear canvas or show error state
           const ctx = mainCtx; // Use main context
           ctx.save();
           // Clear transforms before drawing error message
           ctx.setTransform(1, 0, 0, 1, 0, 0);
           ctx.fillStyle = '#333';
           ctx.fillRect(0, 0, canvas.width, canvas.height);
           ctx.fillStyle = 'red';
           ctx.textAlign = 'center';
           ctx.font = '16px Arial';
           ctx.fillText('Video Error', canvas.width/2, canvas.height/2);
           ctx.restore();
        });

        /* --- Desktop interactions: Pan/Zoom/Click --- */
        let startX, startY, isDragging = false;
        // Mousedown: Initiate drag panning (if space held or fullscreen)
        canvasWrapper.addEventListener("mousedown", e => {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          // Only pan if spacebar is held OR if in fullscreen mode
          if (e.button === 0 && (spaceHeld || isFs)) {
            startX = e.clientX;
            startY = e.clientY;
            isDragging = false; // Reset dragging flag
            container.style.cursor = 'grabbing'; // Indicate panning possible
            e.preventDefault(); // Prevent text selection, etc.
          }
        });

        // Mousemove: Perform panning if dragging
        document.addEventListener("mousemove", e => {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          // Check if left button is down, pan condition met, and drag initiated
          if ((e.buttons & 1) && (spaceHeld || isFs) && typeof startX === 'number') {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            // Start dragging only after moving a few pixels
            if (!isDragging && Math.hypot(dx, dy) > 5) {
              isDragging = true;
            }
            if (isDragging) {
              // Update pan based on mouse movement and current zoom scale
              container.panX += dx / container.zoomScale;
              container.panY += dy / container.zoomScale;
              // Pass canvas to clampPan
              clampPan(container, canvas);
              savePlayerSettings(url, { zoomScale: container.zoomScale, panX: container.panX, panY: container.panY });
              // Update start position for next move delta
              startX = e.clientX;
              startY = e.clientY;
            }
          }
        });

        // Mouseup: End panning
        document.addEventListener("mouseup", e => {
          if (e.button === 0 && typeof startX === 'number') {
            container.style.cursor = ''; // Reset cursor
            startX = null; // Clear start position
            startY = null;
            // Reset dragging flag slightly later to prevent click event firing immediately
            setTimeout(() => isDragging = false, 0);
          }
        });

        // Wheel: Perform zooming (if space held or fullscreen)
        canvasWrapper.addEventListener("wheel", e => {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          // Only zoom if spacebar is held OR if in fullscreen mode
          if (spaceHeld || isFs) {
            e.preventDefault(); // Prevent page scroll
            const rect = canvasWrapper.getBoundingClientRect();
            // Calculate mouse position relative to the canvas wrapper
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            // Normalize mouse coordinates (0 to 1)
            const normX = mouseX / rect.width;
            const normY = mouseY / rect.height;
            // Convert normalized coords to canvas coords (based on canvas drawing surface size)
            const canvasX = normX * canvas.width;
            const canvasY = normY * canvas.height;

            const oldZoom = container.zoomScale;
            const zoomAmount = 0.15; // Zoom sensitivity
            // Calculate new zoom level
            let newZoom = oldZoom * (e.deltaY < 0 ? (1 + zoomAmount) : (1 / (1 + zoomAmount)));
            newZoom = Math.max(1, Math.min(5, newZoom)); // Clamp zoom between 1x and 5x

            if (newZoom !== oldZoom) {
              // Adjust pan to keep the point under the mouse stationary
              // Use canvas center for calculation
              const canvasCenterX = canvas.width / 2;
              const canvasCenterY = canvas.height / 2;
              container.panX += (canvasX - canvasCenterX) * (1/newZoom - 1/oldZoom);
              container.panY += (canvasY - canvasCenterY) * (1/newZoom - 1/oldZoom);
              container.zoomScale = newZoom; // Apply new zoom
              // Pass canvas to clampPan
              clampPan(container, canvas);
              savePlayerSettings(url, { zoomScale: container.zoomScale, panX: container.panX, panY: container.panY });
            }
          }
        }, { passive: false }); // Need passive:false to preventDefault

        // Click/Double-Click: Play/Pause or Fullscreen
        let clickTimeout = null;
        let lastClickTime = 0;
        const handleDesktopClick = e => {
          // If the click was handled by the sidebar closing logic (capture phase), do nothing here.
          if (e.defaultPrevented) {
              return;
          }

          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          // Ignore clicks on overlay controls
          if (e.target.closest('.overlay-icon') || e.target.closest('.right-sidebar')) return;
          // Ignore clicks outside the container (covers canvas and black bars in FS)
          if (!container.contains(e.target)) return;
          // Ignore right-clicks or if currently dragging
          if (e.button !== 0 || isDragging) return;

          const now = Date.now();
          if (now - lastClickTime < 300) { // Double-click detected
            clearTimeout(clickTimeout); // Cancel single-click action
            lastClickTime = 0; // Reset timer
            // Toggle fullscreen
            if (!isFs) enterNativeFullScreen(container);
            else exitNativeFullScreen();
          } else { // Potential single-click
            clickTimeout = setTimeout(() => {
              // Toggle play/pause if click was within container
               if (video.paused) video.play().catch(()=>{});
               else video.pause();
            }, 300); // Wait for potential double-click
          }
          lastClickTime = now; // Record click time
        };
        // Use bubbling phase for the main click handler
        container.addEventListener("click", handleDesktopClick, false);


        /* --- Desktop Controls Bar --- */
        const controlBar = document.createElement("div");
        controlBar.className = "control-bar";
        controlsContainer.appendChild(controlBar);

        // Play/Pause Button
        const playPauseBtn = document.createElement("button");
        playPauseBtn.textContent = video.paused ? "Play" : "Pause";
        playPauseBtn.setAttribute("aria-label","Play/Pause");
        playPauseBtn.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click
          if (video.paused) video.play().catch(()=>{});
          else video.pause();
        });
        // Update button text on video state change
        video.addEventListener("play", () => playPauseBtn.textContent = "Pause");
        video.addEventListener("pause", () => playPauseBtn.textContent = "Play");
        video.addEventListener("ended", () => playPauseBtn.textContent = "Play");
        controlBar.appendChild(playPauseBtn);

        // Progress Bar
        const progressBar = document.createElement("div");
        progressBar.className = "progress-bar";
        const bufferedBar = document.createElement("div");
        bufferedBar.className = "buffered";
        const playedBar = document.createElement("div");
        playedBar.className = "played";
        const thumb = document.createElement("div");
        thumb.className = "thumb";
        progressBar.appendChild(bufferedBar);
        progressBar.appendChild(playedBar);
        progressBar.appendChild(thumb);
        controlBar.appendChild(progressBar);

        // Update progress bar display
        function updateProgressBar() {
          // Check if stalled using the player object's flag
           if (playerObject.isBuffering) {
               // Don't update playhead if stalled
               spinner.classList.add('visible'); // Ensure spinner is visible
               return;
           } else {
               spinner.classList.remove('visible'); // Ensure spinner is hidden if not buffering
           }

          const d = video.duration;
          // Check if duration is valid number
          if (!isNaN(d) && d > 0 && isFinite(d)) {
            const ct = video.currentTime;
            const b = video.buffered;
            let bEnd = 0;
            // Find buffered end time relevant to current time
            try { // Add try-catch for robustness
              for (let i = 0; i < b.length; i++) {
                if (b.start(i) <= ct && b.end(i) >= ct) {
                  bEnd = b.end(i);
                  break;
                }
                // Fallback: use the latest buffered end time if none contain current time
                bEnd = Math.max(bEnd, b.end(i));
              }
            } catch {} // Ignore potential errors accessing buffered ranges
            const pp = (ct / d) * 100; // Played percentage
            const bp = (bEnd / d) * 100; // Buffered percentage
            playedBar.style.width = `${Math.min(100, pp)}%`;
            thumb.style.left = `${Math.min(100, pp)}%`;
            bufferedBar.style.width = `${Math.min(100, bp)}%`;

            // Stall detection based on time not advancing
            if (!video.paused && video.readyState >= video.HAVE_FUTURE_DATA) {
                if (video.currentTime === playerObject.previousTime) {
                    // Time hasn't advanced, potential stall
                    playerObject.isBuffering = true;
                    spinner.classList.add('visible');
                } else {
                    // Time advanced, not stalled
                    playerObject.isBuffering = false;
                    spinner.classList.remove('visible');
                }
            } else if (video.paused) {
                 playerObject.isBuffering = false; // Not buffering if paused
                 spinner.classList.remove('visible');
            }
            playerObject.previousTime = video.currentTime; // Update previous time

          } else {
            // Reset if duration is invalid (e.g., live stream with no duration)
            playedBar.style.width = '0%';
            thumb.style.left = '0%';
            bufferedBar.style.width = '0%';
            playerObject.previousTime = 0; // Reset previous time
          }
        }
        // Update on relevant video events
        ["timeupdate", "progress", "loadedmetadata", "durationchange", "seeking", "seeked", "play", "pause"].forEach(evt => {
          video.addEventListener(evt, updateProgressBar);
        });
        updateProgressBar(); // Initial update

        // Progress Bar Seeking Logic
        let isSeeking = false;
        function seek(event) {
          const d = video.duration;
          if (!isNaN(d) && d > 0 && isFinite(d)) {
            const pr = progressBar.getBoundingClientRect();
            let cX = event.clientX; // Mouse X
            // Handle touch events if needed (though primarily desktop)
            if (event.type.startsWith('touch')) {
              if (event.touches.length > 0) cX = event.touches[0].clientX;
              else if (event.changedTouches.length > 0) cX = event.changedTouches[0].clientX;
            }
            const clickX = cX - pr.left; // X relative to progress bar
            let sp = clickX / pr.width; // Seek percentage
            sp = Math.max(0, Math.min(1, sp)); // Clamp between 0 and 1
            const st = sp * d; // Seek time

            // Check if the target time is seekable (optional but good practice)
            let seekable = false;
            try {
              for (let i = 0; i < video.seekable.length; i++) {
                if (st >= video.seekable.start(i) && st <= video.seekable.end(i)) {
                  seekable = true; break;
                }
              }
            } catch { seekable = true; } // Assume seekable if error

            if (seekable) {
              video.currentTime = st; // Set video time
              updateProgressBar(); // Update display immediately
            }
          }
        }
        // Mouse down on progress bar starts seeking
        progressBar.addEventListener("mousedown", e => {
          if (e.button === 0) { // Left click only
            isSeeking = true;
            progressBar.classList.add('seeking'); // Add class for thumb style
            document.body.style.userSelect = 'none'; // Prevent text selection during drag
            seek(e);
            progressBar.style.cursor = 'grabbing';
          }
        });
        // Touch start (basic support)
        progressBar.addEventListener("touchstart", e => {
          isSeeking = true;
           progressBar.classList.add('seeking');
          document.body.style.webkitUserSelect = 'none'; // iOS selection prevent
          seek(e);
        }, { passive: true });
        // Mouse move updates seek position if seeking
        document.addEventListener("mousemove", e => { if (isSeeking) seek(e); });
        // Touch move updates seek position
        document.addEventListener("touchmove", e => {
          if (isSeeking) {
            e.preventDefault(); // Prevent scrolling page
            seek(e);
          }
        }, { passive: false });
        // Mouse up ends seeking
        document.addEventListener("mouseup", e => {
          if (e.button === 0 && isSeeking) {
            isSeeking = false;
            progressBar.classList.remove('seeking');
            progressBar.style.cursor = 'pointer';
            document.body.style.userSelect = '';
          }
        });
        // Touch end ends seeking
        document.addEventListener("touchend", e => {
          if (isSeeking) {
            isSeeking = false;
            progressBar.classList.remove('seeking');
            document.body.style.webkitUserSelect = '';
          }
        });

        // Fullscreen Button (Desktop Native)
        const fsBtnDesktop = document.createElement("button");
        fsBtnDesktop.innerHTML = "&#x26F6;"; // Fullscreen symbol
        fsBtnDesktop.setAttribute("aria-label","Enter/Exit Fullscreen");
        fsBtnDesktop.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click
          if (!document.fullscreenElement && !document.webkitFullscreenElement) {
            enterNativeFullScreen(container);
          } else {
            exitNativeFullScreen();
          }
        });
        controlBar.appendChild(fsBtnDesktop);

        // Update fullscreen button icon based on state
        function updateFsBtn() {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          fsBtnDesktop.innerHTML = isFs ? "&#x2921;" : "&#x26F6;"; // Exit/Enter symbols
          // Trigger canvas resize when FS state changes
          resizeCanvas();
        }
        document.addEventListener("fullscreenchange", updateFsBtn);
        document.addEventListener("webkitfullscreenchange", updateFsBtn);

        // Reset Pan/Zoom Button
        const resetBtn = document.createElement("button");
        resetBtn.textContent = "Reset";
        resetBtn.className = "reset-btn"; // Add class if specific styling needed
        resetBtn.setAttribute("aria-label","Reset Pan & Zoom");
        resetBtn.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click
          container.zoomScale = 1;
          container.panX = 0;
          container.panY = 0;
          savePlayerSettings(url, { zoomScale: 1, panX: 0, panY: 0 });
          // No need to manually redraw, renderCanvas loop handles it
        });
        controlBar.appendChild(resetBtn);

        // Disable/Hide Stream Button
        const disableBtn = document.createElement("button");
        disableBtn.className = "disable-btn";
        disableBtn.textContent = "✕"; // Close symbol
        disableBtn.setAttribute("aria-label","Hide this stream");
        disableBtn.addEventListener("click", e => {
          e.stopPropagation(); // Prevent container click
          updateStreamEnabled(url, false); // Call main function to hide/remove
        });
        controlBar.appendChild(disableBtn);

        // Title Bar below controls
        const tb = document.createElement("div");
        tb.className = "title-bar";
        tb.textContent = title;
        controlsContainer.appendChild(tb);

        /* --- Auto-hide controls in fullscreen --- */
        let hideControlsTimeout = null;
        function showControlsTemporarily() {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          if (!isFs) return; // Only applies in fullscreen
          controlsContainer.style.opacity = '1';
          controlsContainer.style.pointerEvents = 'auto';
          clearTimeout(hideControlsTimeout);
          // Don't auto-hide if paused or buffering
          if (!video.paused && !playerObject.isBuffering) {
            hideControlsTimeout = setTimeout(() => {
              controlsContainer.style.opacity = '0';
              controlsContainer.style.pointerEvents = 'none';
            }, 3000); // Hide after 3 seconds of inactivity
          }
        }
        // Show controls on mouse move/enter in fullscreen
        container.addEventListener('mousemove', showControlsTemporarily);
        container.addEventListener('mouseenter', showControlsTemporarily);
        // Keep controls visible when paused or waiting
        video.addEventListener('pause', showControlsTemporarily);
        video.addEventListener('waiting', showControlsTemporarily);
        // Start hide timer when playing (and not buffering)
        video.addEventListener('play', showControlsTemporarily);

        // Set initial controls visibility based on fullscreen state
        function setInitialControlsVisibility() {
          const isFs = document.fullscreenElement === container || document.webkitFullscreenElement === container;
          if (isFs) {
            showControlsTemporarily(); // Start hidden timer if playing
          } else {
            // Ensure controls are visible when not fullscreen
            controlsContainer.style.opacity = '1';
            controlsContainer.style.pointerEvents = 'auto';
            clearTimeout(hideControlsTimeout); // Cancel any hide timer
          }
        }
        document.addEventListener("fullscreenchange", setInitialControlsVisibility);
        document.addEventListener("webkitfullscreenchange", setInitialControlsVisibility);

        // Add resize listener for canvas adjustments
        window.addEventListener("resize", playerObject.resizeHandler); // Handle window resize too

      }

      /* --- HLS.js Setup (Common for Mobile/Desktop HLS) --- */
      if (!isMp4) {
        // Prefer native HLS on Safari/iOS if supported
        const preferNativeHls = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const canPlayNativeHls = video.canPlayType("application/vnd.apple.mpegurl");

        if (Hls.isSupported() && !preferNativeHls) {
          // Use HLS.js
          hlsInstance = new Hls({
            // Configuration options for stability
            maxBufferLength: 30,       // Default: 30
            maxMaxBufferLength: 60,   // Default: 600 - Reduce significantly for live
            liveSyncDurationCount: 4,  // Default: 3 - How many segments behind edge to sync to
            liveMaxLatencyDurationCount: 10, // Default: Infinity - Allow falling further behind edge
            maxBufferHole: 0.8,         // Default: 0.5 - Tolerate slightly larger gaps
            fragLoadingTimeOut: 20000, // Timeout for fragment loading
            manifestLoadingTimeOut: 20000, // Timeout for manifest loading
            levelLoadingTimeOut: 20000, // Timeout for level playlist loading
            // Custom loader to conditionally prepend proxy URL
            loader: class extends Hls.DefaultConfig.loader {
              load(context, config, callbacks) {
                let requestUrl = context.url;
                // Only proxy if on mobile
                if (IS_MOBILE) {
                    // Avoid double-proxying if URL already starts with it
                    while (requestUrl.startsWith(PROXY_PREFIX)) {
                      requestUrl = decodeURIComponent(requestUrl.slice(PROXY_PREFIX.length));
                    }
                    context.url = PROXY_PREFIX + encodeURIComponent(requestUrl);
                } else {
                    // On desktop, ensure we are using the original URL (remove proxy if somehow present)
                     while (requestUrl.startsWith(PROXY_PREFIX)) {
                      requestUrl = decodeURIComponent(requestUrl.slice(PROXY_PREFIX.length));
                    }
                    context.url = requestUrl;
                }
                super.load(context, config, callbacks);
              }
            }
          });
          playerObject.hls = hlsInstance; // Add hls instance to player object

          hlsInstance.loadSource(url); // Load the original (non-proxied) URL
          hlsInstance.attachMedia(video); // Attach HLS.js to the video element

          // Attempt to play when manifest is parsed
          hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
            if (video.autoplay || !video.paused) { // Respect autoplay and current state
                video.play().catch(()=>{}); // Attempt play
            }
          });

          // HLS.js error handling - Enhanced
          hlsInstance.on(Hls.Events.ERROR, (event, data) => {
            console.error(`HLS Error: Type=${data.type}, Details=${data.details}`, data);

            if (data.fatal) {
              // Handle fatal errors (Network, Manifest, etc.)
              switch(data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  console.log("Network error, retrying load...");
                  setTimeout(() => { if (hlsInstance) hlsInstance.startLoad(); }, 2000);
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  console.log("Fatal media error, attempting recovery...");
                  if (hlsInstance) hlsInstance.recoverMediaError();
                  break;
                default:
                  console.log("Unrecoverable HLS error, destroying instance.");
                  if (hlsInstance) {
                      hlsInstance.destroy();
                      hlsInstance = null;
                      playerObject.hls = null;
                  }
                  // Optional: Schedule a full player rebuild
                  // setTimeout(() => { ... }, 5000);
                  break;
              }
            } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
              // Handle non-fatal media errors (like buffer stalls/holes)
              switch (data.details) {
                case Hls.ErrorDetails.BUFFER_STALLED_ERROR:
                case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:
                  console.warn(`Non-fatal media error (${data.details}), attempting recovery.`);
                  if (hlsInstance) {
                    hlsInstance.recoverMediaError();
                  }
                  break;
                case Hls.ErrorDetails.BUFFER_FULL_ERROR:
                  // Usually not an issue, but log it
                  console.log("Buffer full, HLS.js should handle this.");
                  break;
                 // Potentially handle other non-fatal media errors if needed
              }
            }
          });

        } else if (canPlayNativeHls) {
          // Use native HLS playback
          console.log(`Using native HLS for ${url}`);
          // Conditionally use proxy
          video.src = IS_MOBILE ? PROXY_PREFIX + encodeURIComponent(url) : url;
          // Native HLS often requires explicit play action
          if (video.autoplay) {
             video.play().catch(()=>{});
          }
          // Add basic error listener for native playback
          video.addEventListener('error', e => {
             console.error(`Native HLS Error for ${url}:`, video.error);
             // Optionally display error in UI
             const tb = container.querySelector('.title-bar, .video-title-row span');
             if(tb) {
                 tb.textContent = `Error: ${video.error?.message || 'Could not load stream'}`;
                 tb.style.color = 'red';
             }
          });

        } else {
          // HLS not supported at all
          console.warn(`HLS not supported in this browser for ${url}`);
          const em = document.createElement('div');
          em.textContent = 'HLS playback not supported in this browser.';
          em.style.cssText = 'color:red; text-align:center; padding:20px; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.7); border-radius:5px;';
          // Add error message to appropriate place (canvas wrapper or container)
          const target = container.querySelector('.canvas-wrapper') || container;
          target.appendChild(em);
        }
      }

      // Return the fully constructed player object
      return playerObject;
    }

    /* --- Mobile Pseudo-Fullscreen Logic --- */
    let pseudoFsCleanup = null; // Store cleanup function for current fullscreen instance

    function enterPseudoFullscreen(container, video) {
      // Prevent entering if already in fullscreen
      if (document.querySelector('.player-fullscreen-mobile')) return;

      const htmlEl = document.documentElement;
      const isMp4 = container.classList.contains('mp4-player');

      // Add classes to lock body scroll and style fullscreen
      htmlEl.classList.add("pseudo-fullscreen-mobile");
      if (!IS_SAFARI_MOBILE) htmlEl.classList.add("non-safari"); // Specific style tweaks if needed
      container.classList.add("player-fullscreen-mobile");

      // Attempt to play video when entering fullscreen
      if (video.paused) video.play().catch(()=>{});

      let controlsCleanup = null;
      let gestureCleanup = null;

      if (!isMp4) {
        // Setup custom controls and gestures for HLS streams
        const controls = setupMobileFullscreenControls(container, video);
        // Pass control show/hide functions to gesture setup
        const gestures = setupPseudoFullscreenGestures(container, video, controls.showFsControls, controls.hideFsControls);
        controlsCleanup = controls.cleanup;
        gestureCleanup = gestures.cleanup;
        // Store control API on the player object if it exists
        if (players[container.dataset.url]) {
          players[container.dataset.url].controlsApi = {
            showFsControls: controls.showFsControls,
            hideFsControls: controls.hideFsControls
          };
        }
      } else {
        // For MP4, just ensure native controls are visible
        video.controls = true;
      }

      // Store the combined cleanup function
      pseudoFsCleanup = () => {
        if (controlsCleanup) controlsCleanup();
        if (gestureCleanup) gestureCleanup();
        // Remove control API from player object
        if (players[container.dataset.url]) delete players[container.dataset.url].controlsApi;
      };

      // Attempt to hide browser UI elements (address bar) on non-Safari
      if (!IS_SAFARI_MOBILE) hideBrowserUI();
    }

    function exitPseudoFullscreen(container, video) {
      if (!container || !container.classList.contains('player-fullscreen-mobile')) return;

      const htmlEl = document.documentElement;
      const isMp4 = container.classList.contains('mp4-player');

      // Run cleanup for controls/gestures
      if (pseudoFsCleanup) { pseudoFsCleanup(); pseudoFsCleanup = null; }

      // Remove fullscreen classes
      htmlEl.classList.remove("pseudo-fullscreen-mobile", "non-safari");
      container.classList.remove("player-fullscreen-mobile", "controls-open");

      if (!isMp4) {
        // Reset HLS video transform and origin
        video.style.transform = 'scale(1) translate(0px, 0px)';
        video.style.transformOrigin = 'center center';
      } else {
        // Ensure MP4 controls are still enabled (might be turned off by browser)
        video.controls = true;
      }

      // Remove custom fullscreen controls if they exist
      const fsControls = container.querySelector('.fullscreen-controls');
      if (fsControls) fsControls.remove();

      // Reset body/html styles potentially modified for fullscreen
      document.body.style.height = '';
      document.body.style.overflow = '';
      document.body.style.position = '';
      htmlEl.style.height = '';
      htmlEl.style.overflow = '';
      htmlEl.style.minHeight = '';
    }


    /* --- Mobile Fullscreen Controls Setup --- */
    function setupMobileFullscreenControls(container, video) {
      let fsControls = container.querySelector('.fullscreen-controls');
      let controlsTimeout_fs;
      let isFsSeeking = false;
      let listeners = []; // Store added listeners for cleanup

      // Helper to add listeners and track them
      function addListener(el, type, fn, opts) {
        el.addEventListener(type, fn, opts);
        listeners.push({ el, type, fn, opts });
      }

      // Function to show controls
      function showFsControls() {
        if (!fsControls || !container.classList.contains('player-fullscreen-mobile')) return;
        // Animate controls into view
        fsControls.style.bottom = `env(safe-area-inset-bottom, 10px)`; // Account for safe area
        container.classList.add("controls-open");
        clearTimeout(controlsTimeout_fs); // Cancel any pending hide timer
      }

      // Function to hide controls
      function hideFsControls() {
        if (!fsControls || !container.classList.contains('player-fullscreen-mobile')) return;
        // Don't hide if currently seeking
        if (!isFsSeeking) {
          fsControls.style.bottom = '-120px'; // Animate controls out of view
          container.classList.remove("controls-open");
        }
      }

      // If controls already exist (e.g., re-entering fullscreen quickly), just return API
      if (fsControls) {
        container.classList.remove("controls-open"); // Ensure starts hidden
        hideFsControls();
        // Return existing cleanup function if available
        return { cleanup: fsControls.cleanupFsListeners || (() => {}), showFsControls, hideFsControls };
      }

      // Create controls HTML
      fsControls = document.createElement("div");
      fsControls.className = "controls-container fullscreen-controls";

      const fsControlBar = document.createElement("div");
      fsControlBar.className = "control-bar";

      const fsPlayPauseBtn = document.createElement("button");
      fsPlayPauseBtn.textContent = video.paused ? "Play" : "Pause";
      fsControlBar.appendChild(fsPlayPauseBtn);

      const fsProgressBar = document.createElement("div");
      fsProgressBar.className = "progress-bar";
      const fsBufferedBar = document.createElement("div");
      fsBufferedBar.className = "buffered";
      const fsPlayedBar = document.createElement("div");
      fsPlayedBar.className = "played";
      const fsThumb = document.createElement("div");
      fsThumb.className = "thumb";
      fsProgressBar.appendChild(fsBufferedBar);
      fsProgressBar.appendChild(fsPlayedBar);
      fsProgressBar.appendChild(fsThumb);
      fsControlBar.appendChild(fsProgressBar);

      const fsExitBtn = document.createElement("button");
      fsExitBtn.innerHTML = "&#x2921;"; // Exit fullscreen symbol
      fsControlBar.appendChild(fsExitBtn);

      fsControls.appendChild(fsControlBar);

      const fsTitleBar = document.createElement("div");
      fsTitleBar.className = "title-bar";
      fsTitleBar.textContent = extractTitle(container.dataset.url);
      fsControls.appendChild(fsTitleBar);

      container.appendChild(fsControls);

      // --- Add Event Listeners ---

      // Update Play/Pause button text
      const updateFsPlayBtn = () => {
        fsPlayPauseBtn.textContent = video.paused ? "Play" : "Pause";
      };
      addListener(video, "play", updateFsPlayBtn);
      addListener(video, "pause", updateFsPlayBtn);
      addListener(video, "ended", updateFsPlayBtn);

      // Update Progress Bar display
      const updateFsProgressBar = () => {
        const d = video.duration;
        if (!isNaN(d) && d > 0 && isFinite(d)) {
          const ct = video.currentTime;
          const b = video.buffered;
          let bEnd = 0;
          try {
            for (let i = 0; i < b.length; i++) {
              if (b.start(i) <= ct && b.end(i) >= ct) {
                bEnd = b.end(i); break;
              }
              bEnd = Math.max(bEnd, b.end(i));
            }
          } catch {}
          const pp = (ct / d) * 100;
          const bp = (bEnd / d) * 100;
          fsPlayedBar.style.width = `${Math.min(100, pp)}%`;
          fsThumb.style.left = `${Math.min(100, pp)}%`;
          fsBufferedBar.style.width = `${Math.min(100, bp)}%`;
        } else {
          fsPlayedBar.style.width = '0%';
          fsThumb.style.left = '0%';
          fsBufferedBar.style.width = '0%';
        }
      };
      ["timeupdate", "progress", "loadedmetadata", "durationchange"].forEach(evt => {
        addListener(video, evt, updateFsProgressBar);
      });
      updateFsProgressBar(); // Initial update

      // Progress Bar Seeking
      const fsSeek = event => {
        const d = video.duration;
        if (!isNaN(d) && d > 0 && isFinite(d)) {
          const pr = fsProgressBar.getBoundingClientRect();
          let cX = event.clientX;
          // Handle touch input
          if (event.type.startsWith('touch')) {
            if (event.touches.length > 0) cX = event.touches[0].clientX;
            else if (event.changedTouches.length > 0) cX = event.changedTouches[0].clientX;
          }
          const clickX = cX - pr.left;
          let sp = clickX / pr.width;
          sp = Math.max(0, Math.min(1, sp));
          const st = sp * d;
          let seekable = false;
          try { // Check seekable ranges
            for (let i = 0; i < video.seekable.length; i++) {
              if (st >= video.seekable.start(i) && st <= video.seekable.end(i)) {
                seekable = true; break;
              }
            }
          } catch { seekable = true; } // Assume seekable if error
          if (seekable) {
            video.currentTime = st;
            updateFsProgressBar(); // Update display immediately
          }
        }
      };
      addListener(fsProgressBar, "mousedown", e => {
        if (e.button === 0) {
          isFsSeeking = true;
          fsSeek(e);
          fsProgressBar.style.cursor = 'grabbing';
        }
      });
      addListener(fsProgressBar, "touchstart", e => {
        isFsSeeking = true;
        fsSeek(e);
      }, { passive: true });
      // Use window listeners for move/end to catch events outside the bar
      const handleFsMouseMove = e => { if (isFsSeeking) fsSeek(e); };
      const handleFsTouchMove = e => { if (isFsSeeking) { e.preventDefault(); fsSeek(e); } };
      const handleFsMouseUp = e => { if (e.button === 0 && isFsSeeking) { isFsSeeking = false; fsProgressBar.style.cursor = 'pointer'; } };
      const handleFsTouchEnd = () => { if (isFsSeeking) isFsSeeking = false; };
      addListener(window, "mousemove", handleFsMouseMove);
      addListener(window, "touchmove", handleFsTouchMove, { passive: false });
      addListener(window, "mouseup", handleFsMouseUp);
      addListener(window, "touchend", handleFsTouchEnd);

      // Button Actions
      addListener(fsPlayPauseBtn, "click", e => {
        e.stopPropagation();
        if (video.paused) video.play().catch(()=>{});
        else video.pause();
      });
      addListener(fsExitBtn, "click", e => {
        e.stopPropagation();
        exitPseudoFullscreen(container, video);
      });

      // Prevent taps on controls from triggering gestures/play/pause on container
      const handleControlsInteraction = e => {
        e.stopPropagation();
      };
      addListener(fsControls, 'click', handleControlsInteraction);
      addListener(fsControls, 'touchstart', handleControlsInteraction, { passive: true }); // Allow scroll within controls if needed

      // Cleanup function to remove all listeners
      const cleanup = () => {
        listeners.forEach(({ el, type, fn, opts }) => {
          el.removeEventListener(type, fn, opts);
        });
        listeners = []; // Clear the array
        clearTimeout(controlsTimeout_fs); // Clear any pending hide timer
      };
      fsControls.cleanupFsListeners = cleanup; // Attach cleanup to the element itself

      // Store API on the player object
      if (players[container.dataset.url]) {
         players[container.dataset.url].controlsApi = { showFsControls, hideFsControls };
      }

      return { cleanup, showFsControls, hideFsControls };
    }


    /* --- Mobile Pinch/Swipe Gestures Setup --- */
    function setupPseudoFullscreenGestures(container, video, showFsControls, hideFsControls) {
      // State variables for gestures
      let initialDistance = null;   // For pinch zoom
      let initialScale = 1;         // Initial scale before pinch
      let currentScale = 1;         // Current applied scale
      let initialMidpoint = null;   // Midpoint between fingers (screen coords)
      let initialLocalMid = null;   // Midpoint relative to video center
      let gestureRect = null;       // Video bounding rect at gesture start
      let currentTranslateX = 0;    // Current applied X translation
      let currentTranslateY = 0;    // Current applied Y translation
      let gestureStartX = 0;        // Translation X at gesture start
      let gestureStartY = 0;        // Translation Y at gesture start
      let touchStartY = null;       // Y position for swipe detection
      let touchStartTime = null;    // Time for swipe detection
      let isSwipingY = false;       // Flag if vertical swipe detected
      let isGesturing = false;      // Flag if any touch interaction is active

      const listeners = []; // Store listeners for cleanup
      function addListener(el, type, fn, opts) {
        el.addEventListener(type, fn, opts);
        listeners.push({ el, type, fn, opts });
      }
      // Get controls API, default to passed functions if player object not ready
      const controlsApi = players[container.dataset.url]?.controlsApi || { showFsControls, hideFsControls };

      // Apply calculated transform (scale and translate) to the video element
      function applyTransform() {
        // Clamp scale between 1x and 5x
        currentScale = Math.max(1, Math.min(currentScale, 5));
        // Get video dimensions, considering aspect ratio within bounds
        const rect = gestureRect || video.getBoundingClientRect(); // Use stored rect during gesture
        const videoAspect = video.videoWidth / video.videoHeight;
        const containerAspect = rect.width / rect.height;
        let visualW, visualH;
        if (containerAspect > videoAspect) { // Pillarboxed
            visualH = rect.height;
            visualW = visualH * videoAspect;
        } else { // Letterboxed
            visualW = rect.width;
            visualH = visualW / videoAspect;
        }
        // Calculate max translation based on current scale and visual size
        const maxX = (visualW * (currentScale - 1)) / 2;
        const maxY = (visualH * (currentScale - 1)) / 2;
        // Clamp translation
        currentTranslateX = Math.max(-maxX, Math.min(maxX, currentTranslateX));
        currentTranslateY = Math.max(-maxY, Math.min(maxY, currentTranslateY));
        // Apply the transform via CSS
        video.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
      }

      // Touch Start Handler
      const handleTouchStart = e => {
        // Ignore touches starting on controls
        if (e.target.closest('.fullscreen-controls')) return;
        isGesturing = true; // Mark gesture active

        if (e.touches.length === 1) {
          // Prepare for potential swipe
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
          isSwipingY = false; // Reset swipe flag
        } else if (e.touches.length === 2) {
          // Start pinch-zoom/pan gesture
          isSwipingY = false; // Cancel swipe detection
          touchStartY = null;
          const [t1, t2] = e.touches;
          initialDistance = getTouchDistance(t1, t2); // Store initial finger distance
          initialScale = currentScale; // Store scale at gesture start
          initialMidpoint = getTouchMidpoint(t1, t2); // Store midpoint (screen coords)
          gestureRect = video.getBoundingClientRect(); // Store video bounds
          // Calculate midpoint relative to video center for panning adjustment during zoom
          const center = {
            x: gestureRect.left + gestureRect.width / 2,
            y: gestureRect.top + gestureRect.height / 2
          };
          initialLocalMid = {
            x: initialMidpoint.x - center.x,
            y: initialMidpoint.y - center.y
          };
          // Store translation at gesture start
          gestureStartX = currentTranslateX;
          gestureStartY = currentTranslateY;
          // Disable transitions during gesture for smoother updates
          video.style.transition = 'none';
        }
      };

      // Touch Move Handler
      const handleTouchMove = e => {
        if (!isGesturing || e.target.closest('.fullscreen-controls')) return;

        if (e.touches.length === 1 && touchStartY !== null) {
          // Check for vertical swipe gesture
          const dy = e.touches[0].clientY - touchStartY;
          const dt = Date.now() - touchStartTime;
          // Detect swipe after sufficient movement or time
          if (!isSwipingY && (Math.abs(dy) > 10 || dt > 100)) {
            isSwipingY = true;
          }
        } else if (e.touches.length === 2 && initialDistance !== null) {
          // Handle pinch-zoom/pan
          e.preventDefault(); // Prevent page scroll/zoom during gesture
          const [t1, t2] = e.touches;
          const curDist = getTouchDistance(t1, t2); // Current finger distance
          // Calculate new scale based on distance change
          currentScale = initialScale * (curDist / initialDistance);
          const curMid = getTouchMidpoint(t1, t2); // Current midpoint
          // Calculate change in midpoint position
          const deltaX = curMid.x - initialMidpoint.x;
          const deltaY = curMid.y - initialMidpoint.y;
          // Adjust translation: start + midpoint delta - zoom adjustment
          const scaleFactor = currentScale / initialScale;
          currentTranslateX = gestureStartX + deltaX - (initialLocalMid.x * (scaleFactor - 1));
          currentTranslateY = gestureStartY + deltaY - (initialLocalMid.y * (scaleFactor - 1));
          // Apply the new transform
          applyTransform();
        }
      };

      // Touch End Handler
      const handleTouchEnd = e => {
        if (!isGesturing) return;

        // If less than 2 touches remain, pinch gesture ends
        if (e.touches.length < 2) {
          initialDistance = null;
          initialLocalMid = null;
          gestureRect = null; // Clear stored rect
          // Reset transform if zoomed out completely
          if (currentScale <= 1) {
            currentScale = 1;
            currentTranslateX = 0;
            currentTranslateY = 0;
            gestureStartX = 0; // Reset start translation as well
            gestureStartY = 0;
             // Optionally add transition back for smooth reset
            video.style.transition = 'transform 0.2s ease-out';
          } else {
            // Store final translation as the new base for next gesture
            gestureStartX = currentTranslateX;
            gestureStartY = currentTranslateY;
             video.style.transition = ''; // Remove transition if needed
          }
          applyTransform(); // Apply final clamped transform
        }

        // If last touch ended and a swipe was detected
        if (e.touches.length === 0 && isSwipingY && touchStartY !== null) {
          const dy = e.changedTouches[0].clientY - touchStartY;
          const dt = Date.now() - touchStartTime;
          // Check for significant swipe distance/speed
          if (Math.abs(dy) > 50 && dt < 500) {
            const open = container.classList.contains('controls-open');
            if (dy < 0) { // Swipe up -> Show controls
              controlsApi.showFsControls && controlsApi.showFsControls();
            } else { // Swipe down
              if (open) controlsApi.hideFsControls && controlsApi.hideFsControls(); // Hide controls if open
              else exitPseudoFullscreen(container, video); // Exit fullscreen if controls hidden
            }
          }
        }

        // If last touch ended, reset gesture state
        if (e.touches.length === 0) {
          touchStartY = null;
          touchStartTime = null;
          isSwipingY = false;
          isGesturing = false; // Mark gesture inactive
        }
      };

      // Add listeners to the container
      addListener(container, 'touchstart', handleTouchStart, { passive: false }); // Need active for preventDefault
      addListener(container, 'touchmove', handleTouchMove, { passive: false }); // Need active for preventDefault
      addListener(container, 'touchend', handleTouchEnd);
      addListener(container, 'touchcancel', handleTouchEnd); // Handle cancellation

      // Apply initial transform state (in case loaded with zoom/pan)
      applyTransform();

      // Return cleanup function
      return {
        cleanup: () => {
          listeners.forEach(({ el, type, fn, opts }) => el.removeEventListener(type, fn, opts));
          listeners.length = 0; // Clear array
          // Reset video style explicitly on cleanup
          video.style.transform = 'scale(1) translate(0,0)';
          video.style.transformOrigin = 'center center';
          video.style.transition = '';
        }
      };
    }


    /* --- Modal Logic --- */
    function openUrlModal() {
      const streams = getStreamList();
      // Populate textarea with current URLs
      urlInput.value = streams.map(s => s.url).join("\n");
      modalBackdrop.style.display = "block";
      urlModal.style.display = "block";
      document.body.style.overflow = 'hidden'; // Prevent background scroll
    }
    function closeUrlModal() {
      modalBackdrop.style.display = "none";
      urlModal.style.display = "none";
      document.body.style.overflow = ''; // Restore scroll
    }
    function saveUrlsAndClose() {
      // Get URLs from textarea, clean up, and filter valid ones
      const urls = urlInput.value.split("\n")
                      .map(l => l.trim())
                      .filter(l => l && (l.startsWith("http://") || l.startsWith("https://")));
      const existing = getStreamList();
      const newList = [];
      const seen = new Set(); // Track URLs in the new list

      // Build new list, preserving enabled state if URL existed before
      urls.forEach(u => {
        if (!seen.has(u)) { // Avoid duplicates from input
            seen.add(u);
            const ex = existing.find(s => s.url === u);
            newList.push({ url: u, enabled: ex ? ex.enabled : true }); // Default to enabled for new URLs
        }
      });

      saveStreamList(newList); // Save the updated list to localStorage

      // Remove players for URLs no longer in the list
      Object.keys(players).forEach(u => {
        if (!seen.has(u)) {
          updateStreamEnabled(u, false); // This handles removal
        }
      });

      // Add/update players for URLs in the new list
      newList.forEach(cfg => {
        // updateStreamEnabled handles both adding new and ensuring existing are visible if enabled
        updateStreamEnabled(cfg.url, cfg.enabled);
      });

      closeUrlModal();
      updateStreamSidebar(); // Refresh sidebar display
      reorderPlayers(); // Ensure player order matches list order
    }

    /* --- App Initialization --- */
    function initializeApp() {
      updateStreamSidebar(); // Populate sidebar initially

      // Load enabled streams from localStorage
      const streams = getStreamList();
      streams.forEach(stream => {
        if (stream.enabled) {
          const p = createPlayerContainer(stream);
          if (p) {
            mainContent.appendChild(p.container);
            players[stream.url] = p; // Store player instance
          }
        }
      });
      reorderPlayers(); // Initial player order

      // Sidebar button listeners
      btnShowAll.addEventListener("click", () => {
        getStreamList().forEach(s => { if (!s.enabled) updateStreamEnabled(s.url, true); });
      });
      btnHideAll.addEventListener("click", () => {
        getStreamList().forEach(s => { if (s.enabled) updateStreamEnabled(s.url, false); });
      });

      // Modal listeners
      btnAddUrls.addEventListener("click", openUrlModal);
      modalBackdrop.addEventListener("click", closeUrlModal);
      saveUrlsBtn.addEventListener("click", saveUrlsAndClose);

      // Global Escape key listener
      window.addEventListener("keydown", e => {
        if (e.key === "Escape") {
          if (urlModal.style.display === "block") {
            closeUrlModal();
          } else if (document.querySelector('.player-fullscreen-mobile')) {
            // Exit mobile pseudo-fullscreen
            const fs = document.querySelector('.player-fullscreen-mobile');
            if (fs && players[fs.dataset.url]) {
              exitPseudoFullscreen(fs, players[fs.dataset.url].video);
            }
          } else if (document.fullscreenElement || document.webkitFullscreenElement) {
            // Exit native desktop fullscreen
            exitNativeFullScreen();
          }
        }
      });

      // Mobile-specific sidebar toggle logic
      if (IS_MOBILE) {
        sidebar.classList.add("hidden"); // Start hidden on mobile
        sidebarToggle.style.display = "block"; // Show toggle button

        let touchStartX = null;
        const swipeThreshold = 50; // Pixels to swipe left to close

        // Swipe left on sidebar to close
        sidebar.addEventListener("touchstart", e => {
          touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });
        sidebar.addEventListener("touchend", e => {
          if (touchStartX === null) return;
          const deltaX = touchStartX - e.changedTouches[0].screenX; // Positive for left swipe
          if (deltaX > swipeThreshold) {
            sidebar.classList.add("hidden");
            sidebarToggle.style.display = "block";
          }
          touchStartX = null;
        });

        // Toggle button opens sidebar
        sidebarToggle.addEventListener("click", () => {
          sidebar.classList.remove("hidden");
          sidebarToggle.style.display = "none";
        });

        // Tap outside sidebar closes it
        mainContent.addEventListener("touchstart", e => {
          // Check if sidebar is open and tap is not on an interactive element
          if (!sidebar.classList.contains("hidden") &&
              !e.target.closest('button, input, a, .player-container')) {
            sidebar.classList.add("hidden");
            sidebarToggle.style.display = "block";
          }
        }, { passive: true }); // Passive listener for performance
      }
    }

    // Wait for DOM content to load before initializing
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp(); // Initialize immediately if already loaded
    }
  </script>
</body>
</html>